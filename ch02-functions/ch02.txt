Functions
함수

Functions are the building-blocks of Lisp programs. They are also the building-
blocks of Lisp. In most languages the + operator is something quite different
from user-defined functions. But Lisp has a single model, function application, to
describe all the computation done by a program. The Lisp + operator is a function,
just like the ones you can define yourself.

리습 프로그램은 함수가 모여서 만들어집니다. 또 리습 자체도 함수가 모여서 만들어진 것입니다. 대부분의 언어에서 + 연산자와 사용자가 정의한 함수는 완전히 다른 것입니다. 하지만 리습은 프로그램에서 실행되는 모든 연산을 함수로 표현하는 단일 모델을 가지고 있습니다. 리습에서 + 연산자는 함수입니다. 사용자가 정의해서 사용하는 함수와 같은 함수입니다.

In fact, except for a small number of operators called special forms, the core
of Lisp is a collection of Lisp functions. What’s to stop you from adding to this
collection? Nothing at all: if you think of something you wish Lisp could do, you
can write it yourself, and your new function will be treated just like the built-in
ones.

사실 특별형식이라고 불리는 몇몇 연산자를 제외하면 리습의 내부구현은 리습 함수들의 모음일 뿐입니다.
이 모음에 뭔가 추가하지 못할 이유가 없지요.
뭔가 리습이 했으면 하고 생각하신게 있다면, 직접 구현하세요.
직접 만든 함수들이나 리습에 있는 함수들이나 똑같이 사용할 수 있습니다.


This fact has important consequences for the programmer. It means that any
new function could be considered either as an addition to Lisp, or as part of a
specific application. Typically, an experienced Lisp programmer will write some
of each, adjusting the boundary between language and application until the two
fit one another perfectly. This book is about how to achieve a good fit between
language and application. Since everything we do toward this end ultimately
depends on functions, functions are the natural place to begin.

여기서 프로그래머를 위한 중요한 사실이 하나 나타납니다.
새로운 함수를 만든다는 것은 리습에 함수를 추가한다는 것도 되고, 또 자신이 만드는 프로그램에 추가하는 것도 됩니다.
보통 숙력된 리습 프로그래머는 두가지를 다 구현하면서 만들고자하는 프로그램과 언어가 서로 완벽히 맞아떨어지도록 만들어나갑니다.
이 책은 언어와 응용 프로그램이 어떻게하면 잘 어울리게될지를 알려주고자 합니다.
가장 중요한게 함수이므로, 함수에서부터 이야기를 시작하겠습니다.

2.1 Functions as Data
2.1 데이타처럼 사용되는 함수


Two things make Lisp functions different. One, mentioned above, is that Lisp
itself is a collection of functions. This means that we can add to Lisp new operators
of our own. Another important thing to know about functions is that they are Lisp
objects.

리습에서 함수를 특별하게 만드는게 2가지가 있습니다. 
리습 자체가 함수의 모음일 뿐이라는걸 가장 먼저 알아야합니다.
그래서 우리가 만든 새로운 연산자를 리습 언어에 추가할 수 있습니다.
또 우리가 꼭 알아야 할 것은 함수가 리습의 객체라는 것입니다.


Lisp offers most of the data types one finds in other languages. We get
integers and floating-point numbers, strings, arrays, structures, and so on. But
Lisp supports one data type which may at first seem surprising: the function.
Nearly all programming languages provide some form of function or procedure.
What does it mean to say that Lisp provides them as a data type? It means that in
Lisp we can do with functions all the things we expect to do with more familiar
data types, like integers: create new ones at runtime, store them in variables and in
structures, pass them as arguments to other functions, and return them as results.
The ability to create and return functions at runtime is particularly useful.

리습은 다른 언어들이 제공하는 데이타 타입 대부분을 가지고 있습니다.
정수와 부동소수점 수부터 문자열, 배열, 구조체 등등이 있습니다.
하지만 리습에는 누구나 처음 보면 놀랄만한 데이터 타입이 있습니다. 바로 함수입니다.
거의 모든 프로그래밍 언어들이 함수나 프로시저같은 형식을 지원합니다.
리습이 함수를 데이터 타입으로 제공한다는게 무슨 의미일까요?
리습에서 우리는 함수를  가지고 데이터를 가지고 할 수 있는  일들을 할 수 있다는 것입니다.
예를 들면 마치 정수인것처럼 실행중에 새로운 함수를 만들고, 변수나 구조체안에 저장할 수 있습니다.
또한 다른 함수에 인자로 전달할 수도 있고, 결과값으로 반환할 수도 있습니다.
실행중간에 새로운 함수를 만들거나 결과값으로 함수를 반환할 수 있다는 것이 다른 언어와 차별되는 것입니다.


This might sound at first like a dubious sort of advantage, like the self-modifying
machine language programs one can run on some computers. But creating new
functions at runtime turns out to be a routinely used Lisp programming technique.

처음 들으신 분들은 뭐가 장점이라는 것인지 의아하실 것입니다.
마치 어떤 사람들이 어디선가 사용한다는  자기 자신을 수정할 수 있는 기계 코드 와 비슷한것 같이 생각될 것입니다.
하지만 동적으로 새로운 함수를 만드는 것은 리습 프로그래밍에서 흔하게 사용되는 테크닉입니다.

2.2 Defining Functions
2.2 함수 정의

Most people first learn how to make functions with defun. The following expres-
sion defines a function called double which returns twice its argument.
대부분 함수를 정의하는 것이 defun이라고 배우셨을 겁니다.
다음이 인자값의 두배를 반환하는 double이라는 함수를 정의하는 표현입니다.

> (defun double (x) (* x 2))
DOUBLE

Having fed this to Lisp, we can call double in other functions, or from the
toplevel:
리습에 함수를 추가하고나면 다른 함수안에서 double을 호출할 수 있고, 최상위 레벨에서도 호출할 수 있습니다.

> (double 1)
2


A file of Lisp code usually consists mainly of such defuns, and so resembles a
file of procedure definitions in a language like C or Pascal. But something quite
different is going on. Those defuns are not just procedure definitions, they’re
Lisp calls. This distinction will become clearer when we see what’s going on
underneath defun.

리습 코드를 보면 대부분 이런  defun들로 이루어졌다는걸 알 수 있습니다.
마치 C나 파스칼 언어에서 프로시저 정의들과 비슷합니다.
하지만 확연히 다른 점이 존재합나디ㅏ.
이 defun들은 단순히 프로시저를 정의하는게 아닙니다.
그것들은 리습 호출 그 자체입니다.
defun의 내부에  어떤 일이 벌어지는지를 알면 보다 명확해집니다.

Functions are objects in their own right. What defun really does is build one,
and store it under the name given as the first argument. So as well as calling
double, we can get hold of the function which implements it. The usual way to
do so is by using the #’ (sharp-quote) operator. This operator can be understood
as mapping names to actual function objects. By affixing it to the name of double
함수는 객체와 동일합니다. defun이 실제로 하는 일은 하나의 객체를 만들어서 첫번째 인자로 전달된 이름으로 저장하는 것입니다.
그래서 double을 호출하는 것 뿐만 아니라 그것들 정의하는 함수 자체를 맘대로 다룰 수도 있습니다.
바로 #’ (샵-따옴표) 연산자를 이용하면 됩니다.
이 연산자는 전달된 이름에 해당하는 함수의 객체를 얻을 수 있게 해줍니다.
double 이라는 이름에 써보면 


> #’double
#<Interpreted-Function C66ACE>

we get the actual object created by the definition above. Though its printed
representation will vary from implementation to implementation, a Common Lisp
function is a first-class object, with all the same rights as more familiar objects
like numbers and strings. So we can pass this function as an argument, return it,
store it in a data structure, and so on:
> (eq #’double (car (list #’double)))
T
이렇게 함수를 정의할 때 생성된 객체를 얻게 됩니다.
리습 구현마다 출력 양식이 다를 수 있습니다만 커먼 리습에서 함수는  일급객체입니다.
다른 숫자나 문자열같이 좀더 흔한 객체들과 마찬가지입니다.
그래서 우리는 함수를 함수 인자로 전달할 수도 있고, 반환값으로 반환하거나 데이터 구조에 저장하는 등의 일들을 할 수 있게됩니다.

We don’t even need defun to make functions. Like most Lisp objects, we
can refer to them literally. When we want to refer to an integer, we just use the
integer itself. To represent a string, we use a series of characters surrounded by
double-quotes. To represent a function, we use what’s called a lambda-expression.
A lambda-expression is a list with three parts: the symbol lambda, a parameter
list, and a body of zero or more expressions. This lambda-expression refers to a
function equivalent to double:


꼭 함수를 만들 때 defun이 필요한건 아닙니다.
다른 리습 객체들처럼 우리는 함수 그 자체에 접근할 수 있습니다.
우리가 정수를 참조하고 싶을 때 정수를 그대로 사용하는 것과 같습니다.
문자열을 표현하기 위해서 우리는 쌍따옴표로 둘러싸인 문자들이 나열을 사용합니다.
함수를 표현하기 위해서는 람다 표현식이라는걸 사용하면 됩니다.
람다 표현식은 3개의 항목으로 구성된 리스트입니다.
lambda라는 심볼과, 매개변수 리스트, 0개 이상의 표현식으로 구성된 몸체입니다.
람다 표현식으로 double과 동일한 함수를 참조할 수 있습니다.
(lambda (x) (* x 2))

It describes a function which takes one argument x, and returns 2x.
A lambda-expression can also be considered as the name of a function. If
double is a proper name, like “Michelangelo,” then (lambda (x) (* x 2)) is
a definite description, like “the man who painted the ceiling of the Sistine Chapel.”
By putting a sharp-quote before a lambda-expression, we get the corresponding
function:

하나의 인자값 x 를 받아서 2x를 반환하는 함수를 표현해봤습니다.
람다라는 표현을 함수의 이름이라고 생각할 수 있습니다.
double가 이름이고 (lambda (x) (* x 2))라는 표현은 이름에 대한 설명이라고 생각해봅시다.
“미켈란젤로"가 이름이고 “시스틴 예배당의 천장에 그림을 그린 사람"이 설명인것과 같습니다.


> #’(lambda (x) (* x 2))
#<Interpreted-Function C674CE>



This function behaves exactly like double, but the two are distinct objects.
In a function call, the name of the function appears first, followed by the
arguments:

이 함수는 double과 같은 일을 하는데 각각 다른 객체입니다.
함수를 호출할때는 이름을 먼저 쓰고, 그 다음에 인자를 씁니다.

> (double 3)
6


Since lambda-expressions are also names of functions, they can also appear first
in function calls:
람다 표현도 함수 이름이므로 lambda를 가장 먼저 써야합니다.
> ((lambda (x) (* x 2)) 3)
6


In Common Lisp, we can have a function named double and a variable named
double at the same time.

커먼 리습에서 double이라는 함수가 있을 때 동시에 double이라는 변수도 있을 수 있습니다.
> (setq double 2)
2
> (double double)
4

When a name occurs first in a function call, or is preceded by a sharp-quote, it is
taken to refer to a function. Otherwise it is treated as a variable name.
It is therefore said that Common Lisp has distinct name-spaces for variables
and functions. We can have a variable called foo and a function called foo, and
they need not be identical. This situation can be confusing, and leads to a certain
amount of ugliness in code, but it is something that Common Lisp programmers
have to live with.
함수 호출에서 첫번째로 나타나는 이름이나 샤프-따옴표가 붙은 이름은 함수를 나타내는 것입니다. 그 외에는 변수 이름입니다. 이걸보면 함수와 변수가 분리된 이름 공간을 사용한다는걸 알 수 있습니다. foo라는 변수와 foo라는 함수가 있는데 동일한게 아니라니. 혼란스러울 수 있습니다. 코드가 이상해보일 수도 있습니다. 하지만 커먼 리습 프로그래머라면 감당해야합니다.

If necessary, Common Lisp provides two functions which map symbols to the
values, or functions, that they represent. The function symbol-value takes a
symbol and returns the value of the corresponding special variable:
커먼 리습에는 하나의 심볼을 필요에 따라 함수로 쓸건지 변수로 쓸건지 고르게 해주는 2개의 함수를 제공하고 있습니다. symbol-value 함수는 심볼을 받아서 그에 해당하는 변수의 값을 반환합니다.

> (symbol-value ’double)
2

while symbol-function does the same for a globally defined function:
반면에 symbol-fundtion은 전역 함수를 반환합니다.

> (symbol-function ’double)
#<Interpreted-Function C66ACE>
Note that, since functions are ordinary data objects, a variable could have a
function as its value:
함수가 보통의 데이터 객체이므로 변수의 값으로 함수를 저장할 수도 있습니다.

> (setq x #’append)
#<Compiled-Function 46B4BE>
> (eq (symbol-value ’x) (symbol-function ’append))
T


Beneath the surface, defun is setting the symbol-function of its first argu-
ment to a function constructed from the remaining arguments. The following two
expressions do approximately the same thing:
내부를 들여다보면 defun이 하는 일은 첫번째 인자로 symbol-function을 호출하고, 나머지인자들로 함수를 만들어서 연결하는 것입니다. 다음 2개의 표현식은 서로 동일하다고 볼 수 있습니다.
(defun double (x) (* x 2))
(setf (symbol-function ’double)
#’(lambda (x) (* x 2)))

So defun has the same effect as procedure definition in other languages—to
associate a name with a piece of code. But the underlying mechanism is not the
same. We don’t need defun to make functions, and functions don’t have to be
stored away as the value of some symbol. Underlying defun, which resembles
procedure definition in any other language, is a more general mechanism: building
a function and associating it with a certain name are two separate operations.
When we don’t need the full generality of Lisp’s notion of a function, defun
makes function definition as simple as in more restrictive languages.
결국 겉으로보기에 defun은 다른 언어들의 프로시저 정의와 같이 여러개의 코드를 하나의 이름으로 묶는 일을 합니다. 하지만 내부를 들여다보면 같지 않습니다. 함수를 만들기위해 꼭 defun을 써야할 필요가 없습니다. 함수가 특정 심볼에 저장될 필요도 없습니다.  겉으로는 다른 언어들의 프로세저 정의와 같아보이지만 내부에는 좀더 범용적인 메카니즘이 들어있습니다. 함수를 만드는 것과 이름을 붙이는 것이 서로 분리될 수 있기 때문입니다. 우리가 리습에서 정의하는 함수의 범용성을 모두 사용할게 아니라면 defun을 다른 언어들과 같이 단순히 함수를 정의하는데만 사용해도 됩니다.

2.3 Functional Arguments
함수 인자에 함수를 전달하기

Having functions as data objects means, among other things, that we can pass
them as arguments to other functions. This possibility is partly responsible for the
importance of bottom-up programming in Lisp.
함수가 데이터 객체라는 것은 -다른 것들도 있겠지만- 다른 함수에 인자로 넘길 수 있다는것입니다. 리습의 상향식 프로그래밍이 가능한 이유중에 하나가 이것입니다.

A language which allows functions as data objects must also provide some
way of calling them. In Lisp, this function is apply. Generally, we call apply
with two arguments: a function, and a list of arguments for it. The following four
expressions all have the same effect:
어떤 언어가 함수를 데이터 객체와 같게 만들었다면 당연히 그에 맞는 호출 방식도 제공해야합니다. 리습에서는 apply라는 함수가 그런 역할을 합니다. 보통 apply에 2개의 인자를 전달하면 됩니다. 호출할 함수와 함수에 전달할 인자 리스트입니다. 다음 4개의 표현식들은 모두 같은 일을 합니다.

(+ 1 2)
(apply #’+ ’(1 2))
(apply (symbol-function ’+) ’(1 2))
(apply #’(lambda (x y) (+ x y)) ’(1 2))

In Common Lisp, apply can take any number of arguments, and the function
given first will be applied to the list made by consing the rest of the arguments
onto the list given last. So the expression
커먼 리습에서 apply는 인자의 갯수가 제한돼있지 않습니다. apply에서 호루된 함수는 두번째부터 마지막까지 전달된 인자들의 cons 리스트를 인자로 전달받습니다.
(주: cons 리스트라는게 나오는데 나중에 설명이 나옵니다. 간단하게 미리 설명하면 cons 함수로 만든 리스트라는 것입니다.)
(apply #’+ 1 ’(2))

is equivalent to the preceding four. If it is inconvenient to give the arguments as
a list, we can use funcall, which differs from apply only in this respect. This
expression
이 표현은 위의 4개의 표현들과 완전히 동일한 것입니다. 함수 인자로 리스트를 넘기는게 불편하시면 funcall을 쓰면 됩니다. 인자가 리스트가 아니라는 것 외에는 apply와 다른게 없습니다.
(funcall #’+ 1 2)
has the same effect as those above.
위의 것들과 같은 일을 하는 표현입니다.

Many built-in Common Lisp functions take functional arguments. Among the
most frequently used are the mapping functions. For example, mapcar takes two
or more arguments, a function and one or more lists (one for each parameter of
the function), and applies the function successively to elements of each list:
커널 리습에 있는 많은 빌트인 함수들은 함수를 인자로 받습니다. 자주 사용되는 함수들 중에 맵핑 함수가 있습니다. 그중에 mapcar라는게 있는데 두개 이상의 인자를 받습니다. 그 인자는 함수 하나와 한개 이상의 리스트 (각각이 함수에 전달됩니다.)인데, 각각의 리스트마다 한번식 함수가 호출됩니다.
> (mapcar #’(lambda (x) (+ x 10))
’(1 2 3))
(11 12 13)
> (mapcar #’+
’(1 2 3)
’(10 100 1000))
(11 102 1003)

Lisp programs frequently want to do something to each element of a list and get
back a list of results. The first example above illustrates the conventional way to
do this: make a function which does what you want done, and mapcar it over the
list.
리습 프로그램에서는 리스트에 있는 각각의 항목을 가지고 뭔가 일을 하는 경우가 많습니다. 위의 예중에 첫번째 것이 바로 그런 일을 간편하게 실행하는 방법을 보여줍니다. 내가 원하는 일을 하는 함수를 하나 만들고, 리스트의 각 항목에 한번씩 맵핑을 합니다. (주:이렇게 리스트에 있는 항목들을 하나씩 꺼내서 함수에 전달하는걸 mapcar라고 부릅니다.)

Already we see how convenient it is to be able to treat functions as data. In
many languages, even if we could pass a function as an argument to something like
mapcar, it would still have to be a function defined in some source file beforehand.
If just one piece of code wanted to add 10 to each element of a list, we would have
to define a function, called plus ten or some such, just for this one use. With
lambda-expressions, we can refer to functions directly.
함수를 데이터처럼 다룰 수 있다는게 얼마나 편리한 것인지를 봤습니다. 다른 많은 언어들에서는 mapcar같은 함수에 함수를 인자로 전달할 수 있다해도 미리 소스 파일 어딘가에 정의된 함수만을 전달할 수 있습니다. 하나의 리스트 안에 있는 항목들 각각에 10을 더하는 단순한 일을 하는 함수를 만드려고 해도 우리는 함수를 정의하고 호출해야합니다. 한번만 사용하는 함수일때도 그렇습니다. 람다 표현식이 있으면 이럴때 함수를 곧바로 사용할 수 있습니다.

One of the big differences between Common Lisp and the dialects which
preceded it are the large number of built-in functions that take functional argu-
ments. Two of the most commonly used, after the ubiquitous mapcar, are sort
and remove-if. The former is a general-purpose sorting function. It takes a list
and a predicate, and returns a list sorted by passing each pair of elements to the
predicate.
커먼리습과 커먼리습에서 갈라져나온 다른 언어들과 다른것중 큰게 함수를 인자로 많은 빌트인 함수가 많다는 것입니다. 많은 곳에서 사용되는 mapcar 다음으로 또 흔하게 사용되는 것들을 두개만 더 말하자면 sort와 remove-if가 있습니다. sort는 범용적으로 사용할 수 있는 정렬 함수입니다. 리스트와 판별자를 받아서 판별자에 의해 정렬된 리스트를 반환합니다.

> (sort ’(1 4 2 5 6 7 3) #’<)
(1 2 3 4 5 6 7)

To remember how sort works, it helps to remember that if you sort a list with no
duplicates by <, and then apply < to the resulting list, it will return true.
sort가 어떻게 동작하는지를 잘 기억하려면 중복된 항목이 없는 리스트를 <로 정렬할 때 정렬된 리스트에 다시 <를 적용했을 때 참이 반환된다는 것을 기억하면 됩니다.

If remove-if weren’t included in Common Lisp, it might be the first utility
you would write. It takes a function and a list, and returns all the elements of the
list for which the function returns false.
remove-if가 커먼 리습에 이미 포함되어있지 않았다면 우리가 만들어야 할 첫번째 라이브러리 함수가  remove-if였을 겁니다.(주: 그만큼 자주 쓸거란 이야기입니다.)  함수와 리스트를 인자로 받아서 함수가 거짓을 반환한 항목들을 리스트로 만들어서 반환해줍니다.
> (remove-if #’evenp ’(1 2 3 4 5 6 7))
(1 3 5 7)

As an example of a function which takes functional arguments, here is a
definition of a limited version of remove-if:
인자를 함수로 받는게 어떤 것인지 예를 보여드리겠습니다. 아래처럼 간단한 remove-if를 만들어보겠습니다.

(defun our-remove-if (fn lst)
(if (null lst)
nil
(if (funcall fn (car lst))
(our-remove-if fn (cdr lst))
(cons (car lst) (our-remove-if fn (cdr lst))))))
Note that within this definition fn is not sharp-quoted. Since functions are data
objects, a variable can have a function as its regular value. That’s what’s happening
here. Sharp-quote is only for referring to the function named by a symbol—usually
one globally defined as such with defun.
이렇게 정의한 함수를 보면 fn에 샵-따옴표를 붙이지 않은걸 볼 수 있습니다. 함수가 곧 데이터 객체이기 때문에 변수의 값이 함수일 수 있습니다. 그래서 샵-따옴표가 없는 것입니다. 샵-따옴표는 심볼과 같은 이름의  함수에 접근할 때 쓰는 것입니다. 보통 그런 함수는 defun으로 전역적으로 정의된 함수입니다.

As Chapter 4 will show, writing new utilities which take functional arguments
is an important element of bottom-up programming. Common Lisp has so many
utilities built-in that the one you need may exist already. But whether you use
built-ins like sort, or write your own utilities, the principle is the same. Instead
of wiring in functionality, pass a functional argument.
4장에서 보겠지만 인자로 함수를 받는 함수를 구현하는 것은 상향식 프로그래밍에서 중요한 부분입니다. 커먼 리습에는 여러분이 필요로하는 함수들이 대부분 이미 구현되어있을 겁니다. sort같은 빌트인 함수를 쓰거나 직접 만든 함수를 쓰건건에 원칙은 동일합니다. 어떤 기능을 함수 내부에서 구현하는 것보다는 함수에 인자로 전달하는게 우선입니다.(주: 숫자를 정렬할 때 숫자만 정렬하는 함수를 만드는 것보다는 범용적인 함수를 만든다음, 숫자를 처리하는 함수를 따로 만들고, 범용 함수를 전달하는 것입니다. 그러면 범용적인 처리에서 조금씩 더 응용에 특화된 레벨로 올라갈 수 있습니다. 또 개발이 다 끝나갈 무렵에 숫자 처리외에 문자열의 정렬이 필요하다고 요구사항이 바뀌어도 대처할 수 있습니다. 만약 하나의 함수에서 숫자 처리만 가능하도록 만들고 말았다면 설계의 변화나 요구사항의 변화에 대처할 수 없을 것입니다.)


2.4 Functions as Properties
2.4 속성으로 함수를 사용하기

The fact that functions are Lisp objects also allows us to write programs which can
be extended to deal with new cases on the fly. Suppose we want to write a function
which takes a type of animal and behaves appropriately. In most languages, the
way to do this would be with a case statement, and we can do it this way in Lisp
as well:
함수가 리습 객체라는 것 덕분에 갑작스러운 기능 추가 등의 프로그램 확장에 유연하게 대처할 수 있습니다. 동물의 종류를 인자로 받아서 해당하는 동물의 행동을 나타내는 함수를 만든다고 생각해보겠습니다. 다른 언어들은 case문을 사용해서 처리할 것입니다. 리습으로하면 아래처럼 될 것입니다.

(defun behave (animal)
(case animal
(dog (wag-tail)
(bark))
(rat (scurry)
(squeak))
(cat (rub-legs)
(scratch-carpet))))

What if we want to add a new type of animal? If we were planning to add new
animals, it would have been better to define behave as follows:
새로운 타입의 동물을 추가하려면 어떻게 해야할까요? 새로운 동물이 추가될 수 있다는 계획이 있었을 때부터 아래와같이 동물 행동을 구현했다면 더 좋았을 것입니다.

(defun behave (animal)
(funcall (get animal ’behavior)))
and to define the behavior of an individual animal as a function stored, for example,
on the property list of its name:
그리고 각 동물의 행동을 구현할 때, 다음 예처럼 동물 이름으로된 속성 리스트에 함수로 저장할 수 있습니다. (주: dog가 속성 리스트이고 behavior가 속성입니다. 이 책은 이미 lisp의 기본을 아는 사람을 대상으로 한 책이기 때문에 일일이 새로나온 함수를 설명하지 않습니다.)

(setf (get ’dog ’behavior)
#’(lambda ()
(wag-tail)
(bark)))


This way, all we need do in order to add a new animal is define a new property.
No functions have to be rewritten.
이렇게하면 새로운 동물을 추가하기 위해 우리가 할 일은 새로운 속성을 정의하는 것밖에 없게됩니다. 함수를 고칠 필요가 없습니다.

The second approach, though more flexible, looks slower. It is. If speed were
critical, we would use structures instead of property lists and, especially, compiled
instead of interpreted functions. (Section 2.9 explains how to make these.) With
structures and compiled functions, the more flexible type of code can approach or
exceed the speed of versions using case statements.
두번째 방법은 좀더 유연하지만 더 느려보입니다. 실제로도 그렇습니다. 속도가 중요한 상황이라면 속성 리스트 대신에 구조체를 사용했을겁니다. 또 인터프리터에서 함수를 정의할게 아니라 함수를 컴파일해서 사용하는 것도 중요합니다.

This use of functions corresponds to the concept of a method in object-oriented
programming. Generally speaking, a method is a function which is a property of
an object, and that’s just what we have. If we add inheritance to this model, we’ll
have all the elements of object-oriented programming. Chapter 25 will show that
this can be done with surprisingly little code.
이렇게 함수를 사용하는 것은 객체지향 프로그래밍에서 메소드의 개념과 같습니다. 일반적으로 메소드라는 것은 객체의 속성이 함수인 것을 말합니다. 바로 우리가 만든 그대로입니다. 이 방식에 상속 개념을 더하면 객체지향 프로그래밍의 모든 요소를 가지게 됩니다. 25장에서 아주 적은 코드만으로 이런 개념들을 구현하는 것을 보게됩니다.

One of the big selling points of object-oriented programming is that it makes
programs extensible. This prospect excites less wonder in the Lisp world, where
extensibility has always been taken for granted. If the kind of extensibility we
need does not depend too much on inheritance, then plain Lisp may already be
sufficient.
객체지향 프로그래밍의 가장 큰 장점이 프로그램을 확장하기 쉽게 만들어준다는 것입니다. 그런 장점이 리습에는 그리 특별한게 아닌게  리습에서는 확장성이 항상  당연한 것이었기 때문입니다. (주: 객체지향 프로그래밍이 나오기 한참 전에 리습이 만들어졌습니다.) 꼭 상속으로만 구현되는 확장성을 빼고는 기본적인 리습만으로도 충분히 확장성을 제공할 수 있습니다.

2.5 Scope
Common Lisp is a lexically scoped Lisp. Scheme is the oldest dialect with lexical
scope; before Scheme, dynamic scope was considered one of the defining features
of Lisp.
커먼 리습은 렉시컬 유효 범위를 지원하는 언어입니다. 스킴이 첫번째로 렉시컬 유효 범위를 지원하는 리습의 방언이었고, 스킴이 생기기 전에는 리습의 중요한 특징이 다이나믹 유효 범위였습니다.

The difference between lexical and dynamic scope comes down to how an
implementation deals with free variables. A symbol is bound in an expression
if it has been established as a variable, either by appearing as a parameter, or by
variable-binding operators like let and do. Symbols which are not bound are
said to be free. In this example, scope comes into play:
렉시컬 유효범위와 동적 유효범위의 차이는 값이 정해지지않은 변수를 어떻게 처리하느냐에 달려있습니다. 만약 어떤 심볼이 함수 매개 변수에 사용되거나 let, do 같은 변수 선언 연산자를 이용한 표현식을 이용해서 변수라고 정의될 수 있습니다. 그렇게 특정하게 연결된 값이 없다면 값이 정해지지 않은 것입니다. 다음 예제를 보면 유효범위가 어떻게 정해지는지를 알 수 있습니다.

(let ((y 7))
(defun scope-test (x)
(list x y)))
Within the defun expression,x is bound and y is free. Free variables are interesting
because it’s not obvious what their values should be. There’s no uncertainty about
the value of a bound variable—when scope-test is called, the value of x should
be whatever is passed as the argument. But what should be the value of y? This
is the question answered by the dialect’s scope rules.
defun 표현식 내부에서보면 x는 값이 정해졌고 y는 값이 정해지지 않았습니다. 값이 정해지지 않은 변수는 그 값이 뭐가 될지 알 수 없습으므로 주의해야합니다. 값이 지정된 변수는 명확합니다. scope-test 함수가 호출될 때 x의 값은 함수 인자로 전달된 값 그대로입니다. 그럼 y의 값은 뭘까요? 리습의 방언에서 유효범위를 어떻게 규정하느냐에 따라 달라집니다.

In a dynamically scoped Lisp, to find the value of a free variable when exe-
cuting scope-test, we look back through the chain of functions that called it.
When we find an environment where y was bound, that binding of y will be the
one used in scope-test. If we find none, we take the global value of y. Thus, in
a dynamically scoped Lisp, y would have the value it had in the calling expression:
동적 유효범위를 지원하는 리습 방언에서는 scope-test를 실행할 때 값이 정해지지 않은 변수의 값을 찾을 때 함수 호출 고리를 거슬러 올라가면서 값을 찾습니다. 그렇게 올라가다가 y의 값이 정해지는 환경을 만나면 그때 y의 값이 scope-test에서 사용할 값입니다. 만약 값을 찾지 못하면 y의 값이 전역 변수인지 확인합니다. 그래서 동적 유효 범위를 가진 리습에서 y는 y를 사용하는 표현식이 호출될 때의 값을 가집니다.

> (let ((y 5))
(scope-test 3))
(3 5)
With dynamic scope, it means nothing that y was bound to 7 when scope-test
was defined. All that matters is that y had a value of 5 when scope-test was
called.
동적 유효범위에서 scope-test가 정의될 때 y의 값이 7이라는 것은 상관이 없습니다. scope-test가 호출될 때 y의 값이 5라는 것만이 중요합니다.

In a lexically scoped Lisp, instead of looking back through the chain of calling
functions, we look back through the containing environments at the time the
function was defined. In a lexically scoped Lisp, our example would catch the
binding of y where scope-test was defined. So this is what would happen in
Common Lisp:
렉시컬 유효범위(주: 동적 유효범위의 반대라고해서 정적 유효범위라고 부르기도 합니다.)는 함수 호출 고리를 거슬러 올라가는 대신 함수가 정의될 당시의 환경이 어떠했는지를 찾아봅니다. 렉시컬 유효범위를 지원하는 리습에서 위의 예제를 실행하면 scope-test가 정의되는 곳에서 y의 값을 찾습니다. 그래서 커먼 리습에서는 아래처럼 실행이 됩니다.

> (let ((y 5))
(scope-test 3))
(3 7)
Here the binding of y to 5 at the time of the call has no effect on the returned
value.
호출 당시에 y가 5라는 것은 코드의 실행 결과와 상관이 없습니다.

Though you can still get dynamic scope by declaring a variable to be special,
lexical scope is the default in Common Lisp. On the whole, the Lisp community
seems to view the passing of dynamic scope with little regret. For one thing, it
used to lead to horribly elusive bugs. But lexical scope is more than a way of
avoiding bugs. As the next section will show, it also makes possible some new
programming techniques.
특별한 방법을 쓰면 동적 유효 범위를 가지는 변수를 만들 수는 있습니다. 하지만 커먼 리습에서는 렉시컬 유효 범위가 기본입니다. 리습 커뮤니티는 동적 유효 범위를 버린 것에 대해 별로 후회하지 않는것 같습니다. 그것 때문에 정말 찾기 어려운 버그가 생기기도 했었으니까요. 반면에 렉시컬 유효 범위는 버그를 방지하기 쉽습니다. 또 다음 섹션에서 보듯이 새로운 프로그래밍 테크닉이 생겨나기도 했습니다.

2.6 Closures
클로저(주: 클로저는 뭐라고 번역할 수가 없었습니다. 그냥 클로저라고 부르겠습니다.)

Because Common Lisp is lexically scoped, when we define a function containing
free variables, the system must save copies of the bindings of those variables at
the time the function was defined. Such a combination of a function and a set
of variable bindings is called a closure. Closures turn out to be useful in a wide
variety of applications.
커먼 리습이 렉시컬 유효범위를 가진다고 말씀드렸습니다. 그래서 함수가 정의될 때 내부에서 정의되지 않은 변수를 가지고 있다면 시스템은 함수가 정의될 때 어떤 변수들이 어떤 값을 가지고 있는지를 기억해놔야합니다. 그렇게 함수와 변수들의 묶음을 클로저라고 부릅니다. 클로저는 다양한 분야의 응용 프로그램에서 유용하게 사용되고 있습니다.

Closures are so pervasive in Common Lisp programs that it’s possible to use
them without even knowing it. Every time you give mapcar a sharp-quoted
lambda-expression containing free variables, you’re using closures. For example,
suppose we want to write a function which takes a list of numbers and adds a
certain amount to each one. The function list+
클로저는 워낙 커먼 리습 프로그램에 흔하게 사용되고 있어서 뭔지 모르면서도 사용하기도 합니다. mapcar를 호출 할 때 샤프-따옴표를 이용해서 람다 표현식을 넘길때가 있습니다. 그때 람다 표현식 안에 람다 표현식 밖에서 정의된 변수가 있다면 클로저를 사용한 것입니다. 예제를 만들어보겠습니다. 숫자로 이루어진 리스트를 받아서 특정 수를 더하는 함수를 만드려고 합니다. 함수 이름은 list+ 입니다.

(defun list+ (lst n)
(mapcar #’(lambda (x) (+ x n))
lst))
will do what we want:
위와같이 만들어서 아래와같이 사용할 수 있습니다.
> (list+ ’(1 2 3) 10)
(11 12 13)

If we look closely at the function which is passed to mapcar within list+, it’s
actually a closure. The instance of n is free, and its binding comes from the
surrounding environment. Under lexical scope, every such use of a mapping
function causes the creation of a closure. 1
list+ 함수를 보면 mapcar에 사용된 람다 표현식이 클로저라는 것을 알 수 있습니다. n의 값이 람다 표현식 밖에서 정의된 것입니다. 렉시컬 스코프에서는 (주:mapcar같은) 맵핑 함수를 사용할 때마다 클로저가 생성된다고 보면 됩니다. (저자주1)

Closures play a more conspicuous role in a style of programming promoted
◦ by Abelson and Sussman’s classic Structure and Interpretation of Computer Pro-
grams. Closures are functions with local state. The simplest way to use this state
is in a situation like the following:
클로저는 Abelson과 Sussman 이 쓴 유명한 고전 Structure and Interpretation of Computer Programs 에서 자주 사용하는 프로그래밍 스타일입니다. 클로저는 자신만의 상태를 가지는 함수라고 할 수 있습니다. 이 상태를 사용하는 방법은 다음과 같은 상황에서 잘 나타납니다.

(let ((counter 0))
(defun new-id ()
(incf counter))
(defun reset-id () (setq counter 0)))
These two functions share a variable which serves as a counter. The first one
returns successive values of the counter, and the second resets the counter to 0.
The same thing could be done by making the counter a global variable, but this
way it is protected from unintended references.
카운터 역할을 하는 변수를 두개의 함수가 공유하고 있습니다. 첫번째 함수는 카운터를 증가시키고 두번째 함수는 0으로 초기화합니다. 전역 변수로 선언된 카운터로 같은 일을 할 수 있지만 위와 같이 구현하면 의도치않은 곳에서 카운터에 접근하는 것을 막을 수 있습니다. 

It’s also useful to be able to return functions with local state. For example, the
function make-adder
개별 상태를 가진 함수를 반환하는 것도 유용할 때가 있습니다. 다음과 같은 make-adder 함수를 보면

(defun make-adder (n)
#’(lambda (x) (+ x n)))
takes a number, and returns a closure which, when called, adds that number to its
argument. We can make as many instances of adders as we want:
숫자를 받아서 클로저를 반환합니다. 이 클로저는 호출될때마다 인자로 전달된 숫자만큼 값을 더합니다. 결국 아래처럼 여러가지의 덧셈기를 만들 수가 있게 됩니다.

(저자주:1. Under dynamic scope the same idiom will work for a different reason—so long as neither of
mapcar’s parameter is called x.)
(저자주1: 동적 스코프에서도 똑같이 동작하지만 이유는 다릅니다. (해석못함)

> (setq add2 (make-adder 2)
add10 (make-adder 10))
#<Interpreted-Function BF162E>
> (funcall add2 5)
7
> (funcall add10 3)
13
In the closures returned by make-adder, the internal state is fixed, but it’s also
possible to make closures which can be asked to change their state.
make-add로 만들어진 클로저들은 내부 상태가 고정되어있습니다. 하지만 내부 상태를 바꿀 수 있게 만들 수도 있습니다.

(defun make-adderb (n)
#’(lambda (x &optional change)
(if change
(setq n x)
(+ x n))))
This new version of make-adder returns closures which, when called with one
argument, behave just like the old ones.
새로 만든 make-adder는 인자가 하나일때 이전 클로저와 동일하게 동작하는 클로저를 반환합니다.

> (setq addx (make-adderb 1))
#<Interpreted-Function BF1C66>
> (funcall addx 3)
4
However, when the new type of adder is called with a non-nil second argument,
its internal copy of n will be reset to the value passed as the first argument:
그런데 두번째 인자가 nil값이 아닐때의 동작이 다릅니다. 내부 상태에서 n의 값이 첫번째 인자의 값으로 바뀝니다.

> (funcall addx 100 t)
100
> (funcall addx 3)
103
It’s even possible to return a group of closures which share the same data
objects. Figure 2.1 contains a function which creates primitive databases. It takes
an assoc-list (db), and returns a list of three closures which query, add, and delete
entries, respectively.
같은 데이터 객체를 공유하는 여러개의 클로저를 만드는 것도 가능합니다. 그림 2.1에는 아주 단순한 데이터베이스를 만들기위한 함수가 있습니다. db에 연관 리스트를 받아서 3개의 함수로 이루어진 리스트를 반환합니다. 그 함수는 쿼리, 추가, 삭제 기능을 하는 함수입니다.

Each call to make-dbms makes a new database—a new set of functions closed
over their own shared copy of an assoc-list.
make-dbms를 호출할 때마다 새로운 데이터베이스가 만들어지고, 연관 리스트를 공유하는 함수들의 집합이 생성됩니다.

> (setq cities (make-dbms ’((boston . us) (paris . france))))
(#<Interpreted-Function 8022E7>
#<Interpreted-Function 802317>
#<Interpreted-Function 802347>)

그림2.1시작
(defun make-dbms (db)
(list
#’(lambda (key)
(cdr (assoc key db)))
#’(lambda (key val)
(push (cons key val) db)
key)
#’(lambda (key)
(setf db (delete key db :key #’car))
key)))
Figure 2.1: Three closures share a list.
그림2.1: 하나의 리스트를 공유하는 세개의 클로저

The actual assoc-list within the database is invisible from the outside world—we
can’t even tell that it’s an assoc-list—but it can be reached through the functions
which are components of cities:
데이터 베이스 내부에 있는 연관리스트는 외부에서는 볼 수 없습니다. 밖에서는 그게 연관리스트인지도 알 수 없습니다. cities를 구성하는 함수들을 통해서만 접근할 수 있습니다.
> (funcall (car cities) ’boston)
US
> (funcall (second cities) ’london ’england)
LONDON
> (funcall (car cities) ’london)
ENGLAND
Calling the car of a list is a bit ugly. In real programs, the access functions might
instead be entries in a structure. Using them could also be cleaner—databases
could be reached indirectly via functions like:
car를 가지고 list에 접근하는 것은 불편합니다. 실제 프로그램에서는 리스트 구조체에 접근하기 위한 전용 접근 함수를 만들어서 사용하게 될 것입니다. 그렇게하는게 훨씬 깔끔합니다. 즉 다음과 같이 데이터베이스에 간접적으로 접근하게해주는 함수가 있을 수 있습니다.

(defun lookup (key db)
(funcall (car db) key))
However, the basic behavior of closures is independent of such refinements.
In real programs, the closures and data structures would also be more elaborate
than those we see in make-adder or make-dbms. The single shared variable could
be any number of variables, each bound to any sort of data structure.
어쨌든 클로저의 기본 동작은 그런 추가작업과는 상관이 없습니다. 실제 프로그램에서 사용되는 클로저와 데이터 구조는 make-adder나 make-dbms에서 보는 것보다는 더 정교할 것입니다. 하나의 공유 변수대신에 여러개의 변수들을 공유할 수 있고, 각 변수들은 각기 다른 데이터 구조일 수도 있습니다.

Closures are one of the distinct, tangible benefits of Lisp. Some Lisp programs
could, with effort, be translated into less powerful languages. But just try to
translate a program which uses closures as above, and it will become evident how
much work this abstraction is saving us. Later chapters will deal with closures in
more detail. Chapter 5 shows how to use them to build compound functions, and
Chapter 6 looks at their use as a substitute for traditional data structures.
클로저는 리습만의 고유하고 중요한 특징입니다. 어떤 리습 프로그램들은 덜 강력한 언어로도, 노력만하면, 만들 수 있는 것들일수 있습니다. 하지만 위와 같이 클로저를 사용하는 프로그램을 다른 언어로 만들어보려고 해보면, 클로저를 이용한 추상화가 얼마나 많은 일들을 간략하게 만들어주는지 알 수 있게 됩니다. 나중에 다른 챕터에서 클로저를 좀더 자세하게 다룰 것입니다. 5장에서 클로저를 이용해서 여러가지 기능을 가진 함수들을 만들어볼 것이고, 6장에서는 전통적인 데이터 구조 대신에 클로저를 사용하는 방법을 알아보겠습니다.

2.7 Local Functions
2.7 지역함수

When we define functions with lambda-expressions, we face a restriction which
doesn’t arise with defun: a function defined in a lambda-expression doesn’t have
a name and therefore has no way of referring to itself. This means that in Common
Lisp we can’t use lambda to define a recursive function.
람다 표현식으로 함수를 만들 때 defun으로 함수를 만들 때에는 없던 제약이 있습니다. 람다 표현식으로 함수를 만들면 함수의 이름이 없기 때문에 자기 자신을 호출할 방법이 없습니다. 즉 커먼 리습에서 람다를 이용한 재귀 함수를 만들 수 없다는 이야기가 됩니다.

◦
If we want to apply some function to all the elements of a list, we use the most
familiar of Lisp idioms:
리스트에 있는 각 항목에 어떤 함수를 적용하고 싶을 때 보통 아래처럼 합니다.

> (mapcar #’(lambda (x) (+ 2 x))
’(2 5 7 3))
(4 7 9 5)
What about cases where we want to give a recursive function as the first argument
to mapcar? If the function has been defined with defun, we can simply refer to
it by name:
map의 첫번째 인자로 재귀 함수를 지정하고 싶을 때는 어떻게 해야할까요? defun으로 정의된 함수라면 다음처럼 간단하게 해결됩니다.

> (mapcar #’copy-tree ’((a b) (c d e)))
((A B) (C D E))
But now suppose that the function has to be a closure, taking some bindings from
the environment in which the mapcar occurs. In our example list+,
mapcar가 실행될 때의 환경을 기억하는 클로저로 함수를 만드는걸 생각해보겠습니다. 다음 예제의 list+ 함수를 보겠습니다.

(defun list+ (lst n)
(mapcar #’(lambda (x) (+ x n))
lst))
the first argument to mapcar, #’(lambda (x) (+ x n)), must be defined within
list+ because it needs to catch the binding of n. So far so good, but what if we
want to give mapcar a function which both needs local bindings and is recursive?
mapcar의 첫번째 인자는 #’(lambda (x) (+ x n))입니다. 이 람다 함수는 list+ 안에서만 정의될 수 있습니다. n 변수를 list+함수에서 받아야하기 때문입니다. 여기까지는 문제가 없습니다. 그런데 만약 mapcar에 지역 변수와 재귀가 필요한 함수를 전달하고 싶을 때는 어떻게 해야할까요?

We can’t use a function defined elsewhere with defun, because we need bindings
from the local environment. And we can’t use lambda to define a recursive
function, because the function will have no way of referring to itself.
Common Lisp gives us labels as a way out of this dilemma. With one
important reservation, labels could be described as a sort of let for functions.
defun 밖에서 정의된 함수를 쓸수 없습니다. defun 내부의 환경을 사용하기 때문입니다. 그리고 람다로 재귀 함수를 만들 수 없습니다. 람다 함수 내부에서 다시 자기 자신을 호출할 방법이 없기 때문입니다. 커먼 리습은 이런 문제의 해결책으로 labels을 제공하고 있습니다. labels는 함수에게 let과 같은 역할을 합니다.

Each of the binding specifications in a labels expression should have the form
labels 표현식에 뭔가를 선언하려면 다음과 같은 형태로 하면 됩니다.
(<name> <parameters> . <body>)
Within the labels expression, <name> will refer to a function equivalent to:
labels 표현식의 <name>은 함수 이름입니다.

#’(lambda <parameters> . <body>)
So for example:
예를 들면 이렇습니다.
> (labels ((inc (x) (1+ x)))
(inc 3))
4
However, there is an important difference between let and labels. In a let
expression, the value of one variable can’t depend on another variable made by
the same let—that is, you can’t say
let과 labels 사이에 중요한 차이가 있습니다. let은 동시에 같은 let에서 선언된 다른 변수에 접근할 수 없습니다.

(let ((x 10) (y x))
y)
and expect the value of the new y to reflect that of the new x. In contrast, the body of
a function f defined in a labels expression may refer to any other function defined
there, including f itself, which makes recursive function definitions possible.
Using labels we can write a function analogous to list+, but in which the
first argument to mapcar is a recursive function:
(defun count-instances (obj lsts)
(labels ((instances-in (lst)
(if (consp lst)
(+ (if (eq (car lst) obj) 1 0)
(instances-in (cdr lst)))
0)))
(mapcar #’instances-in lsts)))
This function takes an object and a list, and returns a list of the number of
occurrences of the object in each element:
> (count-instances ’a ’((a b c) (d a r p a) (d a r) (a a)))
(1 2 1 2)
2.8 Tail-Recursion
A recursive function is one that calls itself. Such a call is tail-recursive if no
work remains to be done in the calling function afterwards. This function is not
tail-recursive
(defun our-length (lst)
(if (null lst)
0
(1+ (our-length (cdr lst)))))
because on returning from the recursive call we have to pass the result to 1+. The
following function is tail-recursive, though2.8
TAIL - RECURSION
23
(defun our-find-if (fn lst)
(if (funcall fn (car lst))
(car lst)
(our-find-if fn (cdr lst))))
because the value of the recursive call is immediately returned.
Tail-recursion is desirable because many Common Lisp compilers can trans-
form tail-recursive functions into loops. With such a compiler, you can have the
elegance of recursion in your source code without the overhead of function calls
at runtime. The gain in speed is usually great enough that programmers go out of
their way to make functions tail-recursive.
A function which isn’t tail-recursive can often be transformed into one that is
by embedding in it a local function which uses an accumulator. In this context, an
accumulator is a parameter representing the value computed so far. For example,
our-length could be transformed into
(defun our-length (lst)
(labels ((rec (lst acc)
(if (null lst)
acc
(rec (cdr lst) (1+ acc)))))
(rec lst 0)))
where the number of list elements seen so far is contained in a second parameter,
acc. When the recursion reaches the end of the list, the value of acc will be
the total length, which can just be returned. By accumulating the value as we go
down the calling tree instead of constructing it on the way back up, we can make
rec tail-recursive.
Many Common Lisp compilers can do tail-recursion optimization, but not all
of them do it by default. So after writing your functions to be tail-recursive, you
may also want to put
(proclaim ’(optimize speed))
at the top of the file, to ensure that the compiler can take advantage of your efforts. 2
Given tail-recursion and type declarations, existing Common Lisp compilers
can generate code that runs as fast as, or faster than, C. Richard Gabriel gives as ◦
an example the following function, which returns the sum of the integers from 1
to n:
2 The
declaration (optimize speed) ought to be an abbreviation for (optimize (speed 3)).
However, one Common Lisp implementation does tail-recursion optimization with the former, but not
the latter.24
FUNCTIONS
(defun triangle (n)
(labels ((tri (c n)
(declare (type fixnum n c))
(if (zerop n)
c
(tri (the fixnum (+ n c))
(the fixnum (- n 1))))))
(tri 0 n)))
This is what fast Common Lisp code looks like. At first it may not seem natural
to write functions this way. It’s often a good idea to begin by writing a function
in whatever way seems most natural, and then, if necessary, transforming it into a
tail-recursive equivalent.
2.9 Compilation
Lisp functions can be compiled either individually or by the file. If you just type
a defun expression into the toplevel,
> (defun foo (x) (1+ x))
FOO
many implementations will create an interpreted function. You can check whether
a given function is compiled by feeding it to compiled-function-p:
> (compiled-function-p #’foo)
NIL
We can have foo compiled by giving its name to compile
> (compile ’foo)
FOO
which will compile the definition of foo and replace the interpreted version with
◦ a compiled one.
> (compiled-function-p #’foo)
T
Compiled and interpreted functions are both Lisp objects, and behave the same,
except with respect to compiled-function-p. Literal functions can also be
compiled: compile expects its first argument to be a name, but if you give nil
as the first argument, it will compile the lambda-expression given as the second
argument.2.9
COMPILATION
25
> (compile nil ’(lambda (x) (+ x 2)))
#<Compiled-Function BF55BE>
If you give both the name and function arguments, compile becomes a sort of
compiling defun:
> (progn (compile ’bar ’(lambda (x) (* x 3)))
(compiled-function-p #’bar))
T
Having compile in the language means that a program could build and compile
new functions on the fly. However, calling compile explicitly is a drastic measure,
comparable to calling eval, and should be viewed with the same suspicion. 3
When Section 2.1 said that creating new functions at runtime was a routinely
used programming technique, it referred to new closures like those made by
make-adder, not functions made by calling compile on raw lists. Calling
compile is not a routinely used programming technique—it’s an extremely rare
one. So beware of doing it unnecessarily. Unless you’re implementing another
language on top of Lisp (and much of the time, even then), what you need to do
may be possible with macros.
There are two sorts of functions which you can’t give as an argument to
compile. According to CLTL 2 (p. 677), you can’t compile a function “defined
interpretively in a non-null lexical environment.” That is, if at the toplevel you
define foo within a let
> (let ((y 2))
(defun foo (x) (+ x y)))
then (compile ’foo) will not necessarily work. 4 You also can’t call compile
on a function which is already compiled. In this situation, CLTL 2 hints darkly that
“the consequences. . .are unspecified.”
The usual way to compile Lisp code is not to compile functions individually
with compile, but to compile whole files with compile-file. This function
takes a filename and creates a compiled version of the source file—typically with
the same base name but a different extension. When the compiled file is loaded,
compiled-function-p should return true for all the functions defined in the file.
Later chapters will depend on another effect of compilation: when one function
occurs within another function, and the containing function is compiled, the inner
3 An
explanation of why it is bad to call eval explicitly appears on page 278.
The restriction is imposed on interpreted
code for implementation reasons, not because there’s anything wrong with defining functions in distinct
lexical environments.
4 It’s ok to have this code in a file and then compile the file.26
FUNCTIONS
function will also get compiled. C LTL 2 does not seem to say explicitly that this
will happen, but in a decent implementation you can count on it.
The compiling of inner functions becomes evident in functions which return
functions. When make-adder (page 18) is compiled, it will return compiled
functions:
> (compile ’make-adder)
MAKE-ADDER
> (compiled-function-p (make-adder 2))
T
As later chapters will show, this fact is of great importance in the implementation
of embedded languages. If a new language is implemented by transformation,
and the transformation code is compiled, then it yields compiled output—and
so becomes in effect a compiler for the new language. (A simple example is
described on page 81.)
If we have a particularly small function, we may want to request that it be
compiled inline. Otherwise, the machinery of calling it could entail more effort
than the function itself. If we define a function:
(defun 50th (lst) (nth 49 lst))
and make the declaration:
(proclaim ’(inline 50th))
then a reference to 50th within a compiled function should no longer require a
real function call. If we define and compile a function which calls 50th,
(defun foo (lst)
(+ (50th lst) 1))
then when foo is compiled, the code for 50th should be compiled right into it,
just as if we had written
(defun foo (lst)
(+ (nth 49 lst) 1))
in the first place. The drawback is that if we redefine 50th, we also have to
recompile foo, or it will still reflect the old definition. The restrictions on inline
◦ functions are basically the same as those on macros (see Section 7.9).2.10
FUNCTIONS FROM LISTS
27
2.10 Functions from Lists
In some earlier dialects of Lisp, functions were represented as lists. This gave Lisp
programs the remarkable ability to write and execute their own Lisp programs.
In Common Lisp, functions are no longer made of lists—good implementations
compile them into native machine code. But you can still write programs that
write programs, because lists are the input to the compiler.
It cannot be overemphasized how important it is that Lisp programs can
write Lisp programs, especially since this fact is so often overlooked. Even
experienced Lisp users rarely realize the advantages they derive from this feature
of the language. This is why Lisp macros are so powerful, for example. Most
of the techniques described in this book depend on the ability to write programs
which manipulate Lisp expressions.
